// Class automatically generated by Dev-C++ New Class wizard
//#include "mtrand.h"
#include "population.h" // class's header file
#include "BRand.hpp"
#include <math.h>
#include <vector>
#include <iostream>
#include <cstdlib>
#include <boost/random/mersenne_twister.hpp>
#include <boost/random/variate_generator.hpp>
#include <random>
  using boost::variate_generator;

double population::s,population::h,population::hs;

void population::initialize(double sel, double dom)
{
s=sel;
h=dom;
hs=h*s;
}

// class constructor
population::population(int N)
{
    alleleholders[0]=N;
    alleleholders[1]=0;
    alleleholders[2]=0;
    size=N;
}

void population::mutateup(int n)
{
     std::uniform_real_distribution<double> mt_rand{0.0, 1.0};
     for (int i=0;i<n;i++)
     {
         //if ((alleleholders[0]!=0)&&(BRand::Controller.nextOpened()>((0.5*alleleholders[1])/alleleholders[0])))
         if ((alleleholders[0]!=0)&&(mt_rand(gent)>((0.5*alleleholders[1])/alleleholders[0])))
         {alleleholders[0]-=1;
         alleleholders[1]+=1;}
         else if (alleleholders[1]!=0)
         {alleleholders[1]-=1;
         alleleholders[2]+=1;}
     }
}

void population::mutatedown(int n)
{
     std::uniform_real_distribution<double> mt_rand{0.0, 1.0};
     for (int i=0;i<n;i++)
     {
         //if ((alleleholders[2]!=0)&&(BRand::Controller.nextOpened()>((0.5*alleleholders[1])/alleleholders[2])))
         if ((alleleholders[2]!=0)&&(mt_rand(gent)>((0.5*alleleholders[1])/alleleholders[2])))
         {alleleholders[2]-=1;
         alleleholders[1]+=1;}
         else if (alleleholders[1]!=0)
         {alleleholders[1]-=1;
         alleleholders[0]+=1;}
     }
}

void population::clear()
{
    alleleholders[0]=size;
    alleleholders[1]=0;
    alleleholders[2]=0;
}

void population::fix()
{
    alleleholders[0]=0;
    alleleholders[1]=0;
    alleleholders[2]=size;
}

double population::prob()
{
       return (alleleholders[0]+(1.-hs)*alleleholders[1]*0.5)/(alleleholders[0]+(1.-hs)*alleleholders[1]+(1.-s)*alleleholders[2]);
}

void population::populate_from(population &p, int N)
{
    populate_from(p.prob(),N);
}

void population::populate_from(double prob, int N)
{
    alleleholders[0]=0;
    alleleholders[1]=0;
    alleleholders[2]=0;
    if (N!=0) size=N;
    if (prob<0.5) //drawing a binomial variate works faster when p<0.5
       {alleleholders[0]=boost_binom(size,prob*prob);
       alleleholders[1]=boost_binom(size-alleleholders[0],2*prob/(1+prob));
       alleleholders[2]=size-alleleholders[0]-alleleholders[1];
       }
    else  //drawing a binomial variate works faster when p<0.5
       {prob=1-prob;
       alleleholders[2]=boost_binom(size,prob*prob);
       alleleholders[1]=boost_binom(size-alleleholders[2],2*prob/(1+prob));
       alleleholders[0]=size-alleleholders[2]-alleleholders[1];
       }
}

int population::allelenum()
{
return (alleleholders[1]+2*alleleholders[2]);
}

double  population::freq()
{
return (0.5*alleleholders[1]+alleleholders[2])/size;
}


int population::boost_binom(int n, double p)
{
  std::binomial_distribution<> dist(n, p);
  return dist(gent);
}

/*
int population::binom(int n, double p)
{int x=0;
double y=0,c=log(1-p);
if (c==0)
   {//std::cout<<"c is zero!\n";
   return 0;}
while (1)
    {
    y+=ceil(log(BRand::Controller.nextOpened())/c);
    if (y>n) return x;
    x++;
    }
}
*/


population& population::operator= (const population &Source)
{
    // do the copy
    size = Source.size;
    alleleholders[0]=Source.alleleholders[0];
    alleleholders[1]=Source.alleleholders[1];
    alleleholders[2]=Source.alleleholders[2];
    // return the existing object
    return *this;
}

/*
int population::choose_allele()
{
  //double d=BRand::Controller.nextClosed();
  double d = ((double) rand() / (RAND_MAX));
  //cout << "choose" << d << endl;
if (d<(double(alleleholders[0])/size))
   return 0;
else if (d>(1-double(alleleholders[2])/size))
   return 2;
else
   return 1;

}
*/

population::~population()
{
	std::cout<<"destructor called\n";

}
